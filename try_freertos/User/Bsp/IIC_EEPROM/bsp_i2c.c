#include "bsp_i2c.h"


/*
此处使用模拟I2C，其中每次变更SDA和SCL时需要添加延时，提供总线响应时间
scl置1提供总线时钟

起始信号 sda先置1，将scl置1使其处于可变更状态，此时将sda置0，然后复位scl为0
停止信号 sda先置0，将scl置1使其处于可变更状态，再将sda复位为1

应答信号   sda置0（代表应答信号），scl置1然后置0，最后将sda复位为1释放总线
非应答信号 sda置1（代表非应答信号），scl置1然后置0

发送数据 uint8_t数据分为8位，通过&0x8000获取最高位判断是否为1或0，以此将sda置为1或0
        将scl先置1再复位为0，即完成发送，阈值为7，当到发送最后一位时则sda为1.释放总线
				每次循环将数据左移一位，以此完成逐位获取
接收数据 uint8_t 数据，读取前将保存的数据左移一位预留空间，scl置1，读取当前sda时高电平还是低电平
				是高电平则加1，反之将scl复位为0，进行下一次读取
*/

/*
*********************************************************************************************************
*	函 数 名: i2c_Delay
*	功能说明: I2C总线位延迟，最快400KHz
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/

static void BSP_I2C_Delay(void)
{
	
	uint16_t tim;
	for (tim=0;tim<50;tim++);
	
}

/*
*********************************************************************************************************
*	函 数 名: i2c_Start
*	功能说明: CPU发起I2C总线启动信号
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/

void BSP_I2C_Start(void)
{
	
	BSP_I2C_SDA_1();
	BSP_I2C_SCL_1();
	
	BSP_I2C_Delay();
	BSP_I2C_SDA_0();	
	BSP_I2C_Delay();
	
	BSP_I2C_SCL_0();	
	BSP_I2C_Delay();
	
}

/*
*********************************************************************************************************
*	函 数 名: i2c_Stop
*	功能说明: CPU发起I2C总线停止信号
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void BSP_I2C_Stop(void)
{
	
	BSP_I2C_SDA_0();
	BSP_I2C_SCL_1();
	
	BSP_I2C_Delay();
	BSP_I2C_SDA_1();
	BSP_I2C_Delay();
	
	BSP_I2C_SCL_0();
	BSP_I2C_Delay();
	
}

/*
*********************************************************************************************************
*	函 数 名: i2c_SendByte
*	功能说明: CPU向I2C总线设备发送8bit数据
*	形    参：_ucByte ： 等待发送的字节
*	返 回 值: 无
*********************************************************************************************************
*/
void BSP_I2C_SendByte(uint8_t _uByte)
{
	
	uint8_t Send;
	uint8_t i;
	
	/*进行数据传送时，在SCL呈现高电平期间，SDA上的电平必须保持稳定，低电平为数据0，高电平为数据1
	只有在SCL为低电平期间，才允许SDA上的电平改变状态。逻辑0的电平为低电压，而逻辑1则为高电平*/
	/* 先发送字节的高位bit7 */
	for(i=0;i<8;i++)
	{
		if(_uByte &  0x80)
		{
			BSP_I2C_SDA_1();//发送最高位为1
		}else{
			BSP_I2C_SDA_0();//发送最高位为0
		}
		
		BSP_I2C_Delay();
		BSP_I2C_SCL_1();
		BSP_I2C_Delay();
		BSP_I2C_SCL_0();
		if(i==7)
		{
			BSP_I2C_SDA_1();// I2C释放总线
		}
		_uByte<<=1;/* 左移一个bit 准备读取下一位*/
		BSP_I2C_Delay();
	}
	
}

/*
*********************************************************************************************************
*	函 数 名: i2c_ReadByte
*	功能说明: CPU从I2C总线设备读取8bit数据
*	形    参：无
*	返 回 值: 读到的数据
*********************************************************************************************************
*/
uint8_t BSP_I2C_ReadByte(void)
{
	
	uint8_t Read=0;
	uint8_t i;
	
	/* 读到第1个bit为数据的bit7 */
	for(i=0;i<8;i++)
	{
		Read<<=1;
		BSP_I2C_SCL_1();
		BSP_I2C_Delay();
		if(BSP_I2C_SDA_READ())
		{
			Read++;
		}
		BSP_I2C_SCL_0();
		BSP_I2C_Delay();
	}
	return Read;
	
}

 /*
*********************************************************************************************************
*	函 数 名: i2c_WaitAck
*	功能说明: CPU产生一个时钟，并读取器件的ACK应答信号
*	形    参：无
*	返 回 值: 返回0表示正确应答，1表示无器件响应
*********************************************************************************************************
*/
uint8_t BSP_I2C_WaitACK(void)
{
	
	uint8_t ACK;
	BSP_I2C_SDA_1();// I2C释放总线
	BSP_I2C_Delay();
	BSP_I2C_SCL_1();
	BSP_I2C_Delay();
	if(BSP_I2C_SDA_READ())
	{
		ACK=1;
	}else{
		ACK=0;
	}
	BSP_I2C_SCL_0();
	BSP_I2C_Delay();
	return ACK;
	
}

/*
*********************************************************************************************************
*	函 数 名: i2c_Ack
*	功能说明: CPU产生一个ACK信号
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void BSP_I2C_Ack(void)
{
	
	BSP_I2C_SDA_0();/* CPU驱动SDA = 0 */
	BSP_I2C_Delay();
	BSP_I2C_SCL_1();/* CPU产生1个时钟 */
	BSP_I2C_Delay();
	BSP_I2C_SCL_0();
	BSP_I2C_Delay();
	BSP_I2C_SDA_1();/* CPU释放SDA总线 */
	
}


/*
*********************************************************************************************************
*	函 数 名: i2c_NAck
*	功能说明: CPU产生1个NACK信号
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
uint8_t BSP_I2C_Nack(void)
{
	
	BSP_I2C_SDA_1();//生成非应答信号
	BSP_I2C_Delay();
	BSP_I2C_SCL_1();/* CPU产生1个时钟 */
	BSP_I2C_Delay();
	BSP_I2C_SCL_0();
	BSP_I2C_Delay();
	
}

/*
*********************************************************************************************************
*	函 数 名: i2c_CfgGpio
*	功能说明: 配置I2C总线的GPIO，采用模拟IO的方式实现
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void BSP_I2C_GPIO_Config(void)
{
	
	GPIO_InitTypeDef GPIO_InitStruct;
	RCC_AHB1PeriphClockCmd(BSP_I2C_GPIO_CLK,ENABLE);
	
	GPIO_InitStruct.GPIO_Pin=BSP_I2C_SDA_PIN|BSP_I2C_SCL_PIN;
	//输出模式
	GPIO_InitStruct.GPIO_Mode=GPIO_Mode_OUT;
	GPIO_InitStruct.GPIO_Speed=GPIO_Speed_50MHz;
	//开漏模式
	GPIO_InitStruct.GPIO_OType=GPIO_OType_OD;
	//不设置上拉模式
	GPIO_InitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;
	GPIO_Init(BSP_I2C_GPIO_PORT,&GPIO_InitStruct);
	
	/* 给一个停止信号, 复位I2C总线上的所有设备到待机模式 */
	BSP_I2C_Stop();
	
}

/*
*********************************************************************************************************
*	函 数 名: i2c_CheckDevice
*	功能说明: 检测I2C总线设备，CPU向发送设备地址，然后读取设备应答来判断该设备是否存在
*	形    参：_Address：设备的I2C总线地址
*	返 回 值: 返回值 0 表示正确， 返回1表示未探测到
*********************************************************************************************************
*/
uint8_t BSP_I2C_CheckDevice(uint8_t _Address)
{
	
	uint8_t Res;
	
	BSP_I2C_GPIO_Config();
	BSP_I2C_Start();
	BSP_I2C_SendByte(_Address|BSP_I2C_WR);
	Res=BSP_I2C_WaitACK();
	BSP_I2C_Stop();
	return Res;
	
}